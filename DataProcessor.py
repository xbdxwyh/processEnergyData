#coding = utf8
import os
import re
import csv
import numpy as np
import pandas as pd

fpgaPowerThreshold = 2.195239703
fpgaAmpereThreshold = 0.47


raspberryPowerThreshold = 1.36746
raspberryAmpereThreshold = 0.282



######-----------------------------NOTICING!---------------------------------------###############
'''
Before using, delete the first line of the csv file recorded by powerZ,
        and then convert the document into unix style and utf8 encoding
 

This code is used to analyze and process the csv data recorded by PowerZ 
        to calculate the average energy consumption and 
        average running time during the task load

This is an example to use those code to calculate energy and time;
    
    dfList,nameList = getCSVList('./fpgadata')
    dfList,nameList = searchNameInfo(dfList,nameList,"up")
    a,b,c,d,e = getActivePowerFromDataFrame(dfList[0],raspberryAmpereThreshold,'Ibus(A)',10)
    getSumEnergy(a,b,c,d,raspberryPowerThreshold,2)
'''
#######----------------------------NOTICING!----------------------------------------##############



def logReader(logFile):
    '''
    input: a log filename
    return: (Divided by line) all characters contained in the file
    '''
    with open(logFile,'r') as logf:
        return logf.readlines()


def readcsv(filename):
    '''
    input: a csv file name which you want to process
    output: a dataframe generated by this csv file
    
    update: Date  20200922-182654
                Because pandas has exactly the same function, this function is deprecated
    '''
    return pd.read_csv(filename)




def formatTime(timeString):
    '''
    input: a time str like this (xx:xx:xx)
    output: a float time number which is accurated in second
    
    example: input 01:01:10.1,output 3670.1 seconds
    '''
    timeList =  timeString.split(':')
    timeSum = 0
    for time in timeList:
        timeSum = float(timeSum) * 60 + float(time)
    
    return timeSum



def getDir(dataDirName):
    '''
    input: directory name
    output: All files in the folder (including subdirectories)
    '''
    return os.listdir(dataDirName)



def getLogList(dirName):
    '''
    input: a directory name
    output: A list of all files read by line under the folder,File name list
    '''
    logList = []
    for logFile in getDir(dirName):
        logList.append(logReader(dirName+"/"+logFile))
    
    return logList,getDir(dirName)





def getCSVList(dataDirName):
    '''
    input:directory name
    output:The processed dataFrame of all csv data in the data folder
    
    Notice:
    The file should be organized as follows:
        
        processor.py
        folder{
            #subdirectories
            mobilev1{
                some file,
                There can be any file, but there can be only one csv file
            }
            mobilev2{
                mobilev2.csv
                mobilev2.png
                README.MD
                1.txt
                .......
            }
            ...
            #no files,just directory
        }
        
    
    Update:
        Date 20200922-180911
            Modified the function. It turned out that the file can only be read 
                in a fixed storage mode, but now I have to make some changes
            
            Forget it, let's use the new function
                This function will be deprecated in the future
                Because the limit of reading only one csv is too big
            
    '''
    dfList = []
    nameList = []
    for dataDir in getDir(dataDirName):
        fileList = os.listdir(dataDirName+"/"+dataDir)
        #print(fileList)
        for file in fileList:
            if re.search(".csv",file) is not None:
                #print(dataDirName+"/"+dataDir+"/"+file)
                csvDataFrame = pd.read_csv(dataDirName+"/"+dataDir+"/"+file)
                dfList.append(csvDataFrame)
                nameList.append(dataDir)
            else:
                pass
    
    return dfList,nameList


#dfList,nameList = getCSVList('./fpgadata')

def searchNameInfo(dfList,nameList,searchName):
    '''
    This is a program that returns pandas objects matching searchName
    input:  dfList,nameList return by previous function getCSVList
            searchName : the name related you want to search
    
    output :  List of df and name matching the name on the regular.
    
    Date: 2020:09:14:15:21
    
    Author: wyh201921034
    '''
    searchDfList = []
    searchNameList = []
    for index in range(0,len(nameList)):
        if re.search(searchName,nameList[index]) is not None:
            searchDfList.append(dfList[index])
            searchNameList.append(nameList[index])
    
    return searchDfList,searchNameList

def getActivePowerFromDataFrame(dataf,threshold,threName,threNum):
    '''
    input: a data frame generated by function readcsv which is defined above
    output: beginEnergyList,this list report that when you begin to run a code ,Energy consumed by the Raspberry
            beginTimeList,The time of the corresponding energy label
            
            endEnergyList,The energy consumed by the Raspberry Pi when you finish executing the program
            endTimeList,Corresponding to the end of recording time
    
    Judgment flag: when there are five consecutive current values exceeding 0.28, it is judged to start execution
    Why is it set to 0.28? Because the average current of the Raspberry Pi is 0.27.
    
    In order to deal with missing values, we did a little shift on time and energy. 
        Since they are all backward processing,we believe that this can slightly 
        compensate for the error.
    
    
    Since the unit of the recorded data is Watt, in order to convert the energy to 
                Joule as a unit, you need to multiply the result by 3600.
    
    
    Update:     Date:20200922-175645
            1st change:Add an Input ampereThreshold
            The threshold used before was fixed to the threshold of Raspberry Pi static 
                flow, but now it is used in FPGA, so this modification is made
                
            2nd Modified the function name,
            from the "processor" to the current function name "getActivePowerFromDataFrame",
                to make it more meaningful
            
                Date:20200922-2023
            1.Changed the calculation method, using average values instead of continuous values
            2.Modify AmpereThreshold back to threshold, and the type of threshold can be specified
            3.Added a new input, threNum, which can specify the number of threshold statistics.
                Now you can specify the number of judgment thresholds yourself, instead of the fixed five.
            4.Why not delete the return value of rowlist? 
                Because it can quickly help you locate the line where the outlier is located
                when the program has a problem, so that you can make corresponding adjustments to the program.
    '''
    clms = dataf.columns
    beginEnergyList = []
    beginTimeList = []
    endEnergyList = []
    endTimeList = []
    rowlist = []
    flag = True
    for row in range(1,dataf.shape[0]-threNum):
        #for col in range(0,dataf.shape[1]):
        if flag == True:
            #if dataf.iat[row,2]>ampereThreshold and dataf.iat[row+1,2]>ampereThreshold and dataf.iat[row+2,2]>ampereThreshold and dataf.iat[row+3,2]>ampereThreshold and dataf.iat[row+4,2]>ampereThreshold:
            if np.mean(dataf[threName][row:row+threNum]) > threshold:
                if pd.isnull(dataf.iat[row,6]):
                    pass
                else:
                    beginEnergyList.append(dataf.iat[row,6]*3600)
                    beginTimeList.append(formatTime(dataf.iat[row,0]))
                    rowlist.append(row)
                    flag = False
            else:
                pass
        else:
            #if dataf.iat[row,2]<ampereThreshold and dataf.iat[row+1,2]<ampereThreshold and dataf.iat[row+2,2]<ampereThreshold and dataf.iat[row+3,2]<ampereThreshold and dataf.iat[row+4,2]<ampereThreshold :
            if np.mean(dataf[threName][row:row+threNum]) < threshold:
                line = row
                while pd.isnull(dataf.iat[line,6]):
                    line = line-1
                
                endEnergyList.append(dataf.iat[line,6]*3600)
                endTimeList.append(formatTime(dataf.iat[line,0]))
                flag = True
            else:
                pass
    
    return beginEnergyList,beginTimeList,endEnergyList,endTimeList,rowlist



#a,b,c,d,e = getActivePowerFromDataFrame(dfList[4],fpgaAmpereThreshold,'Ibus(A)',10)


def getSumEnergy(beginEnergyList,beginTimeList,endEnergyList,endTimeList,threshold,times):
    '''
    input: beginEnergyList,beginTimeList,endEnergyList,endTimeList,threshold,times
        beginEnergyList,beginTimeList,endEnergyList,endTimeList:    
                These are all generated in the function in the previous step
        threshold:      The threshold is set to the average energy consumed 
            per second when the system is empty.We ran for 20 minutes without 
            load and then tested the average energy consumption.
        times:     How many times did you execute the procedure in the experiment.
    output: Average energy consumption and average time
        
    Calculation:
                    1         endEnergy - beginEnergy
    AVGEnergy =   ——————  *  { ------------------------  -  threshold } * {endTime - beginTime}
                   times        endTime -  beginTime
    '''
    sumEnergy = 0
    sumTime = 0
    testlist = []
    for be,bt,ee,et in zip(beginEnergyList,beginTimeList,endEnergyList,endTimeList):
        #print(et-bt)
        sumEnergy = sumEnergy + ((ee-be)/(et-bt) - threshold)*(et-bt)
        testlist.append(((ee-be)/(et-bt) - threshold)*(et-bt))
        sumTime = sumTime + (et-bt)
        #print(sumEnergy)
    
    return sumEnergy/times,sumTime/times



#getSumEnergy(a,b,c,d,fpgaAmpereThreshold,21)

#dfList,nameList = getCSVList('./fpgadata')




def processCSVList(dfList,nameList,selectDataThreshold,noLoadPowerValue,times,threName,threNum):
    '''
    input:dfList,nameList,threshold,times
        The dflist processed in the previous step,
        The nameList processed in the previous step,
        threshold is set as No-load power,
        times is the number of program executions
    
    output:
        A list of tuples containing model name, average energy consumption, and average time
    
    
    Update:     Date:20200922183552
                    1.Add an Input named ampereThreshold replace original threshold
                    2.Add an Input name powerThreshold replace original threshold
                
                    3.remove the input threshold
                    ampereThreshold:No load current, used to get the value during activity
                    powerThreshold:No load power, used to calculate the total Energy
                
                Date: 20200922204255
                    1.Added the input of threshold name.----threName
                    2.Added input for judging the number.-----threNum
                    3.Change the input ampereThreshold to selectDataThreshold
                    4.Change the input powerThreshold to noLoadPowerValue
    '''
    dataList = []
    for csvDataFrame,csvName in zip(dfList,nameList):
        beginEnergyList,beginTimeList,endEnergyList,endTimeList,rowList = getActivePowerFromDataFrame(csvDataFrame,selectDataThreshold,threName,threNum)
        averageEnergy,averageTime = getSumEnergy(beginEnergyList,beginTimeList,endEnergyList,endTimeList,noLoadPowerValue,times)
        dataList.append((csvName,averageEnergy,averageTime))
    
    return dataList

#processCSVList(dfList,nameList,fpgaAmpereThreshold,fpgaPowerThreshold,times,'Ibus(A)',10)


#processCSVList(dfList,nameList,fpgaAmpereThreshold,times)






def findUseTimeInLine(lineInfo,splitRegrex):
    '''
    input:A string line with numbers, with spaces before and after the numbers
    output: Convert this number from string format to float form.
    
    Update:     
        Date: 20200922-210953
            1.Added input segmentation characters.
            2.Modified the way of dividing lines, using regular division 
                instead of the function that comes with list
            3.Change the function name from lineprocessor to findUseTimeInLine
    '''
    #words = lineInfo.split(' ')
    words = re.split(splitRegrex,lineInfo)
    for word in words:
        if re.search(r"\d+\.\d+",word) is not None:
            return float(word)
        else:
            pass



def findUseTimeInLog(logLines,searchWord,splitRegrex):
    '''
    input:A list of strings composed of files read line by line
    output:Among all the lines in a file, find all the lines that
            contain information about how long the forecast took.
            
    update: in 20200915,17:47
            add a input searchWord
    
        you can search the word not just "Predicted"
    
            Date: 20200922-211356
                1.Added input segmentation characters.
                2.Change the function name from logprocessor to findUseTimeInLog
            
                TEST:findUseTimeInLog(logList[0],'what',r'\s|,') ,return ok
    '''
    timeList = []
    for line in logLines:
        if re.search(searchWord,line) is not None:
            timeList.append(findUseTimeInLine(line,splitRegrex))
        else:
            pass
    
    return timeList




def searchMatchLogInfo(logList,nameList,searchName,searchWordList,splitRegrex):
    '''
    This function processes the output information of darknet,
        finds the information that matches the model and outputs it.
    
    input:logList,nameList : return from previous function ##getLogList##
            searchName : model name you want to search
    
    putput: predicTimeList,You select the calculation time list of the model.
            searchLogNameList:Model name List
    
    Date: 2020:09:14:16:55
        
    Author: wyh201921034
    
    
    Update: Add a input searchWord
            you can search the word matches,not noly "Predicted"
        Date:20200915,17:51
    
    Date: 20200922-211557
                1.Added input segmentation characters.
                2.Change the Input searchWord to searchWordList
                2.Rewrite the matching part, no longer can only match one character, 
                    but input a string to match the part they need
        TEST:p,s = searchMatchLogInfo(logList,nameList,'log',['Network','Load','target'],r'\s|,')
            return OK
    
    '''
    predicTimeList = []
    searchLogNameList = []
    #matchTimeDict = {}
    for name,log in zip(nameList,logList):
        if re.search(searchName,name) is not None:
            matchTimeDict = {}
            for searchWord in searchWordList:
                #predicTimeList.append(findUseTimeInLog(log,searchWord,splitRegrex))
                matchTimeDict[searchWord] = findUseTimeInLog(log,searchWord,splitRegrex)
            predicTimeList.append(matchTimeDict)
            searchLogNameList.append(name)
    
    return predicTimeList,searchLogNameList


def calLogUseTime(nameList,keyWordList,predicTimeList):
    '''
    Input: nameList, keyWordList, predicTimeList.
            nameList is the recorded model name, such as the one you returned above;
            keyWordList is the list of keywords you want to search for above;
            predList is the value returned by the previous function
    
    OutPut:A list that calculates the average value of the 
            keywords corresponding to the time
    
    Date:
        20200922215050
    Author:wyh201921034
    
    TEST: allAvgList = calLogUseTime(s,['Network','Load','target'],p)
        out Like This:
            [('fpgamobile3largelog', {'Network': 1597414147.1411788, 
            'Load': 1597414146.6036339, 'target': 1597414143.2027817}), 
            ('fpgamobile3smalllog', {'Network': 1597413508.0718875, 
            'Load': 1597413507.9180913, 'target': 1597413504.7358532}), 
            ('fpgayolo4log', {'Network': 1597411345.2167456, 
            'Load': 1597411341.109595, 'target': 1597411337.3087392})]
    '''
    
    allAvgList = []
    for name,predTimeLine in zip(nameList,predicTimeList):
        avgTimeDict = {}
        for keyWord in keyWordList:
            avgTimeDict[keyWord] = np.mean(predTimeLine[keyWord])
        
        allAvgList.append((name,avgTimeDict))
    
    return allAvgList


#Use to calculate
'''

[('idol', nan, 0.0), ('mobile3large', 0.5612825791500103, 1.9500000000000015), 
('mobile3small', 0.615282579150022, 1.95), ('yolov3data', nan, 1.7), 
('yolov4', 2.8016338617149565, 5.594999999999999)]

######## Calculate Time 
for line in allAvgList:
    print(line[0],"Calculation Time is ",line[1]['Network'] - line[1]['Load'],"Load Time is ",line[1]['Load'] - line[1]['target'])

fpgamobile3largelog Calculation Time is  0.5375449657440186 Load Time is  3.4008522033691406
fpgamobile3smalllog Calculation Time is  0.15379619598388672 Load Time is  3.1822381019592285
fpgayolo4log Calculation Time is  4.107150554656982 Load Time is  3.800855875015259
'''








'''
##############%%%%%%%%NOTICING%%%%%%%%#######################
In all the calculations below, I will convert the coordinate list used by yolo to represent the 
    bbox into SSD mode and then do the calculation
##############%%%%%%%%NOTICING%%%%%%%%#######################
    
This is the coordinate system in the SSD algorithm, which is different from the opencv, 
    which is used in YOLO(or OpenCV), where x and y are just the opposite of opencv.
    
For Example:
    OpenCV
    0xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    y
    y
    y
    y
    y
    y
    y
    y
    
    but in SSD is:
    0 yyyyyyyyyyyyyyyyyyyyyyyyy
    x
    x
    x
    x
    x
    x
    x
    x
    x
'''



def transPoint2Decimal(x,y,width,height):
    return x/height,y/width




'''
TEST:
    calculatedArea([0,1,3,3])
    return OK
'''
def calculatedArea(bbox):
    return (bbox[3] - bbox[1]) * (bbox[2] - bbox[0])


def getIntersectionBbox(bboxPred,bboxGTruth):
    return [max(bboxPred[0],bboxGTruth[0]),max(bboxPred[1],bboxGTruth[1]),
                    min(bboxPred[2],bboxGTruth[2]),min(bboxPred[3],bboxGTruth[3])]


def transPointDist2PPBbox(bbox):
    '''
    Function Name: Transform Bbox with point position(left top point) and bbox size(width and height)
            to the bbox with two points(the left top point and right down point)
    '''
    return [bbox[1],bbox[0],bbox[1]+bbox[4],bbox[0]+bbox[3]]



'''
TEST:
    calIntersectionUnionRatio([1,1,2,2],[1,1,3,3])
    return 0.25#OK
    calIntersectionUnionRatio([0,0,2,2],[1,1,3,3])
    return 1/7 #OK
    calIntersectionUnionRatio([2,2,4,4],[1,1,3,3])
    return 1/7#OK
    calIntersectionUnionRatio([0,0,1,1],[1,1,3,3])
    return 0#OK
    
'''
def calIntersectionUnionRatio(bboxPred,bboxGTruth):
    bboxInter = getIntersectionBbox(bboxPred,bboxGTruth)
    
    bboxInterArea = calculatedArea(bboxInter)
    
    areaList = [calculatedArea(bbox) for bbox in [bboxPred,bboxGTruth,bboxInter]]
    #bboxUnionArea = calculatedArea(bboxPred)+calculatedArea(bboxGTruth)-calculatedArea(bboxInter)
    bboxUnionArea = areaList[0]+areaList[1] - areaList[2]
    
    intersectionUnionRatio = bboxInterArea/bboxUnionArea
    return intersectionUnionRatio


